<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sample Document - Feedback Demo</title>
  <style>
    body {
      max-width: 720px;
      margin: 40px auto;
      padding: 0 20px;
      font-family: Georgia, "Times New Roman", serif;
      line-height: 1.7;
      color: #333;
    }
    h1 { font-size: 2em; margin-bottom: 0.3em; }
    h2 { font-size: 1.4em; margin-top: 1.8em; }
    p { margin: 1em 0; }
    .meta { color: #666; font-size: 0.9em; font-style: italic; }
    blockquote {
      border-left: 3px solid #7c3aed;
      margin: 1.5em 0;
      padding: 0.5em 1em;
      color: #555;
      background: #f9f5ff;
    }
    code {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .mermaid {
      background: #fafafa;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 20px;
      margin: 2em 0;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: 'default',
      themeVariables: {
        primaryColor: '#e0d5f5',
        primaryTextColor: '#333',
        primaryBorderColor: '#7c3aed',
        lineColor: '#7c3aed',
        secondaryColor: '#f9f5ff',
        tertiaryColor: '#fff'
      }
    });
  </script>
</head>
<body>

<article>
  <h1>The Future of Collaborative Document Editing</h1>
  <p class="meta">Draft v0.1 — Open for review</p>

  <h2>Introduction</h2>
  <p>
    Hearken well, good folk, to this tale of transformation! Through ten winters' passage hath the noble art of scribal collaboration been most wondrously transformed. From the simple trackings of changes upon desktop parchments of yore, to the mystical real-time co-quilling through the clouded aether, the manner in which fellowships of scribes doth create and refine their manuscripts continues its eternal metamorphosis.
  </p>
  <p>
    However, a gap remains between <em>collecting feedback</em> and <em>acting on it</em>.
    Reviewers leave comments, but authors must manually synthesize dozens of suggestions
    into a coherent revision. This process is time-consuming and error-prone.
  </p>

  <h2>System Architecture</h2>
  <p>
    Remarq implements a client-server architecture where annotations are anchored to
    text using TextQuoteSelector and stored in a backend database. Try selecting and annotating
    text in the diagram below to test annotation support for dynamically-rendered content.
  </p>

  <pre class="mermaid">
graph TB
    A[User selects text] --> B[feedback-layer.js]
    B --> C{Create or Load?}
    C -->|Create| D[selectorFromRange]
    C -->|Load| E[rangeFromSelector]
    D --> F[TextQuoteSelector]
    E --> G[Find text in DOM]
    G --> H[highlightRange]
    B --> I[REST API :3333]
    I --> J[(PostgreSQL)]

    style B fill:#7c3aed,stroke:#6d28d9,color:#fff
    style I fill:#7c3aed,stroke:#6d28d9,color:#fff
    style J fill:#f9f5ff,stroke:#7c3aed
  </pre>

  <p>
    The system uses <strong>text anchoring</strong> to maintain annotation positions even when
    the document changes. The TextQuoteSelector stores the exact quoted text plus
    surrounding context, allowing the system to relocate annotations if the document is edited.
  </p>

  <h2>The Annotation Layer</h2>
  <p>
    Hark! The sacred art of Web Annotations, blessed and ordained by the venerable W3C Web Annotation Data Model, doth bestow upon scribes a mechanism most wondrous and powerful for affixing counsel directly unto specific passages of parchment. Unlike those humble marginalia that dwell imprisoned within the sidebar's chamber, these noble annotations are bound fast and true to the very content they addresseth, through the mystical craft of text selectors.
  </p>
  <p>
    Remarq implements this as a lightweight annotation layer that can be embedded
    in any web page. Reviewers highlight text, leave comments, and these annotations
    are stored via a REST API.
  </p>

  <blockquote>
    "The web is a conversation. Annotations make that conversation visible."
  </blockquote>

  <h2>AI-Assisted Revision</h2>
  <p>
    Large language models can bridge the gap between feedback collection and revision.
    By formatting reviewer annotations as structured input to an LLM, we can generate
    a first-pass revision that addresses each piece of feedback. The author then reviews
    the AI's suggestions rather than starting from scratch.
  </p>
  <p>
    This approach preserves human judgment at every step: reviewers provide the feedback,
    the AI proposes changes, and the author makes the final decision. The AI serves as
    a capable assistant that accelerates the revision cycle without replacing human
    creativity or editorial control.
  </p>

  <h2>Workflow</h2>
  <p>The collaborative review workflow follows these stages:</p>

  <pre class="mermaid">
sequenceDiagram
    participant Author
    participant Reviewer
    participant Remarq
    participant Server

    Author->>Remarq: Publish document
    Reviewer->>Remarq: Select text
    Remarq->>Reviewer: Show ✎ Annotate
    Reviewer->>Remarq: Add comment
    Remarq->>Server: POST /comments
    Server-->>Remarq: Save comment
    Remarq->>Remarq: Highlight text

    Reviewer->>Remarq: Click highlight
    Remarq->>Remarq: Open sidebar

    Author->>Remarq: Resolve ✓
    Remarq->>Server: PATCH (status: closed)
    Remarq->>Remarq: Remove highlight
  </pre>

  <p>
    Each step is stored persistently on the server, allowing reviewers to work asynchronously.
    The annotation layer automatically re-anchors comments when the page reloads.
  </p>

  <h2>Class Diagram Example</h2>
  <p>
    Object-oriented design uses classes to model domain entities. Try annotating the class
    names or relationships below to test annotation support on class diagrams.
  </p>

  <pre class="mermaid">
classDiagram
    class Document {
        +String uri
        +String content
        +Date createdAt
        +addAnnotation()
        +render()
    }
    class Annotation {
        +String id
        +String quote
        +String comment
        +String commenter
        +Boolean resolved
        +resolve()
        +delete()
    }
    class TextSelector {
        +String exact
        +String prefix
        +String suffix
        +anchor()
        +serialize()
    }

    Document "1" --> "*" Annotation : contains
    Annotation "1" --> "1" TextSelector : uses
  </pre>

  <h2>State Diagram Example</h2>
  <p>
    State machines help model application behavior. Try selecting state names or transitions.
  </p>

  <pre class="mermaid">
stateDiagram-v2
    [*] --> Draft
    Draft --> UnderReview: Submit for review
    UnderReview --> Draft: Request changes
    UnderReview --> Approved: Approve
    Approved --> Published: Publish
    Published --> Archived: Archive
    Archived --> [*]

    UnderReview --> HasAnnotations: Add comments
    HasAnnotations --> UnderReview: Address feedback
  </pre>

  <h2>Entity Relationship Diagram</h2>
  <p>
    Database schemas visualized with ERD notation. Test annotations on entity names and attributes.
  </p>

  <pre class="mermaid">
erDiagram
    DOCUMENT ||--o{ ANNOTATION : contains
    ANNOTATION ||--o{ REPLY : has
    ANNOTATION }o--|| USER : "created by"
    REPLY }o--|| USER : "created by"

    DOCUMENT {
        string uri PK
        string content
        datetime created_at
    }
    ANNOTATION {
        int id PK
        string uri FK
        string quote
        string prefix
        string suffix
        string comment
        string commenter
        boolean resolved
        datetime created_at
    }
    REPLY {
        int id PK
        int parent_id FK
        string comment
        string commenter
        datetime created_at
    }
    USER {
        string username PK
        string email
        string avatar_url
    }
  </pre>

  <h2>Gantt Chart Example</h2>
  <p>
    Project timelines and task dependencies. Try annotating task names or dates.
  </p>

  <pre class="mermaid">
gantt
    title Remarq Development Timeline
    dateFormat YYYY-MM-DD
    section Planning
    Requirements gathering       :done, req, 2024-01-01, 7d
    Architecture design          :done, arch, after req, 5d

    section Development
    Text anchoring implementation :done, anchor, 2024-01-15, 10d
    Sidebar UI                   :done, sidebar, after anchor, 7d
    API server                   :done, api, after anchor, 5d
    Mermaid support              :active, mermaid, 2024-02-10, 5d

    section Testing
    E2E tests                    :test, after mermaid, 3d
    Bug fixes                    :bugfix, after test, 5d

    section Deployment
    Documentation                :doc, after bugfix, 3d
    NPM publish                  :publish, after doc, 1d
  </pre>

  <h2>Pie Chart Example</h2>
  <p>
    Simple data visualization with labeled segments.
  </p>

  <pre class="mermaid">
pie title Annotation Types Distribution
    "Feature requests" : 42
    "Bug reports" : 28
    "Questions" : 18
    "General feedback" : 12
  </pre>

  <h2>Git Graph Example</h2>
  <p>
    Version control branch and merge visualization.
  </p>

  <pre class="mermaid">
gitGraph
    commit id: "Initial commit"
    commit id: "Add basic annotation"
    branch feature-sidebar
    checkout feature-sidebar
    commit id: "Create sidebar UI"
    commit id: "Add styling"
    checkout main
    commit id: "Fix anchoring bug"
    checkout feature-sidebar
    merge main
    commit id: "Complete sidebar"
    checkout main
    merge feature-sidebar
    commit id: "Release v1.0.0"
  </pre>

  <h2>User Journey Example</h2>
  <p>
    User experience mapping across touchpoints.
  </p>

  <pre class="mermaid">
journey
    title Reviewer's annotation workflow
    section Reading Document
      Open document: 5: Reviewer
      Read content: 4: Reviewer
      Identify issue: 3: Reviewer
    section Adding Feedback
      Select text: 4: Reviewer
      Click Annotate button: 5: Reviewer
      Write comment: 4: Reviewer
      Submit: 5: Reviewer
    section Follow-up
      Receive notification: 4: Reviewer, System
      Read author response: 5: Reviewer
      Mark as resolved: 5: Reviewer
  </pre>

  <h2>Canvas &amp; WebGL Content</h2>
  <p>
    Canvas and WebGL render content as pixels, not DOM text nodes. This text around the
    canvas elements is annotatable, but content rendered <em>inside</em> the canvas is not.
  </p>

  <h3>Canvas 2D</h3>
  <canvas id="canvas2d" width="500" height="100"></canvas>
  <script>
    (function() {
      const ctx = document.getElementById('canvas2d').getContext('2d');
      ctx.fillStyle = '#f3f4f6';
      ctx.fillRect(0, 0, 500, 100);
      ctx.fillStyle = '#333';
      ctx.font = 'bold 18px sans-serif';
      ctx.fillText('This text is rendered on Canvas — not selectable!', 20, 55);
    })();
  </script>

  <h3>WebGL</h3>
  <canvas id="webgl" width="500" height="200"></canvas>
  <script>
    (function() {
      const canvas = document.getElementById('webgl');
      const gl = canvas.getContext('webgl');
      if (!gl) {
        canvas.insertAdjacentHTML('afterend', '<p><em>WebGL not supported</em></p>');
        return;
      }
      gl.clearColor(0.95, 0.95, 0.97, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      // Minimal spinning triangle
      const vs = `attribute vec2 p; void main(){gl_Position=vec4(p,0,1);}`;
      const fs = `precision mediump float; uniform float t; void main(){gl_FragColor=vec4(0.5+0.3*sin(t),0.4,0.9,1);}`;
      function sh(t,s){const o=gl.createShader(t);gl.shaderSource(o,s);gl.compileShader(o);return o;}
      const prg=gl.createProgram();
      gl.attachShader(prg,sh(gl.VERTEX_SHADER,vs));
      gl.attachShader(prg,sh(gl.FRAGMENT_SHADER,fs));
      gl.linkProgram(prg);gl.useProgram(prg);
      const buf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buf);
      const loc=gl.getAttribLocation(prg,'p');gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);
      const tLoc=gl.getUniformLocation(prg,'t');
      function draw(t){
        const a=t*0.002,c=Math.cos(a),s=Math.sin(a);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([0,0.5*c,-0.5*s,-0.5*c+0.3*s,0.5*s,-0.5*c-0.3*s]),gl.STATIC_DRAW);
        gl.uniform1f(tLoc,t*0.001);gl.clear(gl.COLOR_BUFFER_BIT);gl.drawArrays(gl.TRIANGLES,0,3);
        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    })();
  </script>

  <p>
    <strong>Expected behavior:</strong> Selecting text in this paragraph works normally.
    The canvas content above cannot be selected or annotated.
  </p>

  <h2>Conclusion</h2>
  <p>
    By combining open web annotation standards with modern AI, we can create a
    document revision workflow that is both more efficient and more inclusive. Every
    reviewer's voice is heard, and the revision process is transparent and traceable.
  </p>
</article>

<!--
  Feedback Layer Configuration
  ============================
  - data-api-url: Points to the annotation backend server
  - data-content-selector: CSS selector for the annotatable content

  Add ?author=true to the URL to show the "Send Feedback to Claude" button.
-->
<script
  src="/feedback-layer.js"
  data-content-selector="article"
></script>

</body>
</html>
